#!/usr/bin/env perl

=head1 NAME

xtrabackup-helper.pl

=cut

use strict;
use warnings;
use 5.10.00;

use Data::Dumper;
use Getopt::Long;
use File::Basename;
use Cwd 'abs_path';
use File::Temp;
use POSIX;

use constant TFULL => 'full-backuped';
use constant TINC => 'incremental';

my $dir = '/var/backups/mysql/data';
my $mode = 'list';
my $restore;
my $out = $dir . '/../restore';
my $chown;
my $force = 0;
my $full_day = 1;
my $show_man = 0;
my $keep_days = 7;

my $update_url = 'https://raw.github.com/hoegaarden/xtrabackup-helper/master/xtrabackup-helper.pl';


=head1 MODES

When running I<xtrabackup-helper.pl> you can specify the mode with C<-m> / C<--mode> (default: C<list>).

=over

=item C<list>

Lists all backups (full and incremental) in an orderd list. The oldest backup is printed first
(at the beginning / top), the most recent backup ist printed last (at the bottom / end). Indeted
backups show an incremental backup which is based on the backup right above.

Example listing:

    user@host# xtrabackup-helper.pl -m list
    
    2013-07-04_14-14-51
        2013-07-04_14-18-57
    user@host#

=item C<restore>

Restores the a backup. If no C<-r> / C<--restore> is given, the most recent backup gets restored.
Other (older backups) can be selected by the identifier / date from the C<list> mode.

=item C<backup>

Performs the backup of the database server. It does an incremental backup, except the following is true:

=over

=item *

There is no other full backup

=item *

The current day of week (determined by C<date '+%u'>) is the same as the one given via C<--full-day> (which defaults to 1 / monday).

=back

=item C<update>

The script loads the newest version of itself from github and replaces itself

=item C<weedout>

I<not implemented yet>

=back

=cut

my %modes = (
    'list'    => \&doList ,
    'restore' => \&doRestore ,
    'backup'  => \&doBackup ,
    'weedout' => \&doWeedout ,
    'update'  => \&doUpdate
);


# handle commandline arguments
handleCmdline();

# call the function
$modes{ $mode }->();
exit;


=head1 OPTIONS

=over

=item C<--mode>, C<-m>

In which mode to run, see L</MODES>.

=item C<--dir>, C<-d>

The base directory of the backups. It defaults to C</var/backups/mysql/data/>. This dirctory must exist.
C<innobackupex> then puts its default directory structure in there, so one ends up with a subdirectory for
every single backup.

=item C<--restore>, C<-r>

Which backup to restore. Defaults to the most recent one.

=item C<--out>, C<-o>

The directory where to restore to.

=item C<--chown>, C<-c>

A user (or uid) and optionaly a group (or gid) to C<chmod> all files in the C<out> directory to.
If both user and group are given, they need to be seperated by ":".

=item C<--force>, C<-f>

If the C<out> directory is not empty one can force a cleanup with this option. B<ATTENTION>: all files in
the C<out> directory are deleted!

=item C<--full-day>

The day of week when a full backup should be made. Defaults to 1 which means monday.

=item C<--man>, C<--help>, C<-h>

Displays this help /  manpage.

=item C<--keep-days>, C<-k>

This is the minimum of days in the past where it's possible to restore a backup from. defaults to 7.
This means, that e.g. full backups can be older than this setting, because an incremental backup, which
is younger is based on that full backup.

=back


=head1 HINTS and other STUFF

=cut

sub handleCmdline {
    GetOptions(
        'mode|m=s'    => \$mode ,
        'dir|d=s'     => \$dir ,
        'restore=s'   => \$restore ,
        'out=s'       => \$out ,
        'chown=s'     => \$chown ,
        'force|f!'    => \$force ,
        'full-day=i'  => \$full_day ,
        'man|help!'   => \$show_man ,
        'keep-days=i' => \$keep_days
    ) or die();

    if ($show_man) {
        return doShowMan();
    }

    if (scalar @ARGV) {
        die('unknown commandline parameters');
    }
    
    unless ( defined($modes{$mode}) ) {
        die('unknown mode. valid modes are: ' . join(', ', keys(%modes)) );
    }

    unless (-d $dir) {
        die("backup dir $dir must be a directory");
    }
}

=pod

=over

=item *

The REAMDE is generated by C<pod2text xtrabackup-helper.pl E<gt> README>

=cut

sub doShowMan {
    my $bin_path = abs_path($0);

    execCmd('perldoc', $bin_path);
    exit;
}

sub doWeedout {
    if ( $keep_days < 1 ) {
        die('keep-days must be a positiv integer');
    }

    my $target = `date -d '${keep_days} days ago' '+%Y-%m-%d_%H-%M-%S'`;
    chomp($target);
    my @list = @{ getBackupList() };

    my @delete;
    my @tmp;

    while (1) {
        my $cur = shift(@list);
        last unless defined($cur);

        my $cur_id = $cur->[0];

        last if (id2Norm($cur_id) > id2Norm($target));

        if ($cur->[1] eq TFULL) {
            push(@delete, @tmp);
            @tmp = ();
        }

        push(@tmp, $cur_id);
    }

    if (scalar @delete) {
        @delete = map { id2Path($_); } @delete;
        # needs more tests, so just print out what would be done
        execCmd('rm', '-r', @delete );
    }
}

sub doUpdate {
    # perhaps not the safest way ...

    my $bin_path = abs_path($0);
    my $tmp = tmpnam();
    
    execCmd('wget', '-O', $tmp, $update_url);
    execCmd('mv', $bin_path, $bin_path.'.bak');
    execCmd('mv', $tmp, $bin_path);
    execCmd('chmod', '+x', $bin_path);

    say(' ** Update complete ** ');
    exit;
}

sub doBackup {
    unless ($full_day >= 1 && $full_day <= 7) {
        die('full-day must be an integer between 1 (Monday) and 7 (Sunday)');
    }

    my @backup_list = @{ getBackupList() };
    my @full = getFullBackupList(\@backup_list);
    my $make_full = 0;

    my $dow = `date '+%u'`;
    my $today = `date '+%Y-%m-%d'`;
    chomp($dow, $today);

    if (! @full || ($dow eq $full_day && id2Date($full[-1]->[0]) ne $today)) {
        $make_full = 1;
    }

=item *

When making a backup C<innobackupex> is called with the arguments

=over

=item C<--parallel=3>

=item C<--slave-info>

=item C<--safe-slave-backup>

=item C<--rsync>

=item C<--defaults-extra-file=/etc/mysql/debian.cnf>

=back

=cut

    my $dt_str = POSIX::strftime('%Y-%m-%d_%H-%M-%S', localtime);
    my $dir_progress = $dir . '/' . 'in_progress__' . $dt_str . '__';
    my $dir_finished = $dir . '/' . $dt_str;

    my @cmd = (
        'innobackupex',
        '--parallel', 3, '--no-timestamp',
        # '--safe-slave-backup' ,
        '--slave-info', '--rsync', '--defaults-extra-file', '/etc/mysql/debian.cnf'
    );
    if (!$make_full) {
        my $base_dir = $dir . '/' . $backup_list[-1]->[0];
        push(@cmd, '--incremental', '--incremental-basedir', $base_dir);
    }
    push(@cmd, $dir_progress);

    execCmd(@cmd);
    execCmd('mv', $dir_progress, $dir_finished);
}

sub execCmd {
    my @caller = caller(1);

    say '#';
    say '#   [ caller : ' . $caller[3] . ' ]';
    say '# ' . join(' ', @_);
    say '#';

    system(@_);
    
    if ($? == -1) {
        die("failed to execute: $!");
    } elsif ($? & 127) {
        my $msg = sprintf(
            "child died with signal %d, %s coredump" ,
            ($? & 127) ,
            ($? & 128) ? 'with' : 'without'
        );
        die($msg);
    } else {
        my $code = $? >> 8;
        if (0 != $code) {
            die("child exited with code $code");
        }
    }
}

sub readFile {
    my $file = shift;
    my $str = '';

    open(IN, '<', $file)
        or die('cannot read from file '.$file);

    read(IN, $str, 1024)
        or die('cannot read from file '.$file);

    close(IN)
        or die('cannot close file '.$file);

    return $str;
}

sub getBackupList {
    #
    # Why so complicated with the linked list and all the stuff?
    #
    # Just so we can be kind of sure to have a valid chain of
    # inc_backup <- inc_backup <- ... <- full_backup
    # and we don't prepare a inc_backup on top of a wrong/invalid parent
    #

    my $return_others = shift;

    my %heads;
    my @incs;
    my @others;

    my $pattern = $dir . '/*/xtrabackup_checkpoints';
    my @list = glob($pattern);

    foreach (@list) {
        my $cont = readFile($_);
        my $id = basename(dirname($_));

        if ( $cont =~ m/^backup_type\s*=\s*([^\s]+)$/mg ) {
            my $type = $1;

            my ($from) = $cont =~ m/^from_lsn\s*=\s*(\d+)$/mg ;
            my ($to)   = $cont =~ m/^to_lsn\s*=\s*(\d+)$/mg ;

            my $backup = {
                id => $id, type => $type
              , from => $from, to => $to
              , parent => undef
            };

            if ($type eq TFULL) {
                $heads{ $to } =  $backup;
            } elsif ($type eq TINC) {
                push(@incs, $backup);
            } else {
                $backup->{'__unused'} = 'no valid type';
                push(@others, $backup);
            }
        }
    }

    # build the linked list
    foreach my $backup (@incs) {
        my $from = $backup->{from};
        my $to   = $backup->{to};

        unless (defined($heads{$from})) {
            $backup->{'__unused'} = 'no valid base found (LSN)';
            push(@others, $backup);
            next;
        }

        my $parent = $heads{$from};

        $backup->{'parent'} = $parent;
        $heads{$to} = $backup;

        if ($to != $from) {
            delete $heads{$from};
        }
    }

    my @backups;

    # build the flat list from the linked list
    foreach my $head (sort keys %heads) {
        my $cur = $heads{$head};
        my @tmp;

        do {
            push( @tmp, [$cur->{id}, $cur->{type}] );
        } while ( defined($cur->{parent}) && ($cur = $cur->{parent}) );

        push( @backups , reverse @tmp );
    }

    foreach (@others) {
        push( @backups , [$_->{id}, $_->{type}] );
    }

    return $return_others
        ? ( \@backups, \@others )
        : \@backups
    ;
}

sub getFullBackupList {
    my $backup_list = shift || getBackupList();

    # Extract full backup from backup list.
    return grep {
        $_->[1] eq TFULL
    } @{$backup_list};
}

sub doList {
    my ($list, $others) = getBackupList(1);
    my $indent = ' 'x4;

    foreach (@$list) {
    	my $id = $_->[0];
    	my $type = $_->[1];

    	if ($type eq TINC) {
    	    say $indent . $id;
    	    next;
    	}

    	if ($type eq TFULL) {
    	    say "\n" . $id;
    	    next;
    	}

    	push( @$others, [ $id, $type ] );
    }

    if (scalar @$others) {
    	say "\nOthers:";
    	foreach (@$others) {
    	    my $id = $_->[0];
    	    my $type = $_->[1];

    	    say "${indent}${id} : ${type}";
    	}
    }
}

sub doRestore() {
    my $full_list = getBackupList();
    my $target;

    unless (defined($restore)) {
    	$target = @$full_list[-1]->[0];
    } else {
    	$target = $restore;
    }

    my $cur;
    my @restore_list = ();
    
    foreach (@$full_list) {
    	my $id = $_->[0];
    	my $type = $_->[1];
    	
    	last if (id2Norm($id) > id2Norm($target));
    	
    	if ($type eq TFULL) {
    	    @restore_list = ();
    	}
    	
    	$cur = $id;
    	push(@restore_list, $cur);
    }
    
    my $full = shift(@restore_list);
    restoreFull( $full );

    foreach (@restore_list) {
    	restoreInc( $_ );
    }

    restoreFinishUp();
}

sub restoreFinishUp {
    execCmd("innobackupex", "--apply-log", $out);

    if (defined($chown)) {
    	execCmd("chown", "-R", $chown, $out);
    }
}

sub id2Norm {
    my $id = shift;

    if ( $id =~ m/^(\d{4})-(\d{2})-(\d{2})_(\d{2})-(\d{2})-(\d{2})$/ ) {
        my $norm = int(sprintf(
            '%04d%02d%02d%02d%02d%02d' ,
            $1, $2, $3, $4, $5, $6
        ));
        return $norm;
    }
        
    die("id $id not valid!");
}

sub id2Path {
    return $dir . '/' . shift;
}

sub id2Date {
    my $id = shift;

    if ( $id =~ m/^(\d{4})-(\d{2})-(\d{2})_(\d{2})-(\d{2})-(\d{2})$/ ) {
        my $date = sprintf(
            '%04d-%02d-%02d' ,
            $1, $2, $3
        );
        return $date;
    }

    die("id $id not valid!");
}

sub restoreFull {
    my $id = shift;

    if (scalar <$out/*>) {
    	if (!$force) {
    	    die("restore dir $out must be empty");
    	}
    }

    my $src = id2Path($id);

    # make sure, the desination has no slash at the path's end
    $out =~ s@(/+)$@@;

    # make sure, the source has a slash at the path's end
    $src =~ s@(?<!/)$@/@;

    execCmd(
        'rsync',
        '-vrltH', '--delete', '-pgo', '-S', '-D', '--numeric-ids', '-x',
        $src, $out
    );

    execCmd("innobackupex", "--apply-log", "--redo-only", $out);
}

sub restoreInc {
    my $id = shift;
    my $path = id2Path($id);

    my $tmp_dir = $path . '/../restore__' . $id;

    execCmd('cp', '-a', $path, $tmp_dir);
    execCmd("innobackupex", "--apply-log", "--redo-only", $out, "--incremental-dir", $tmp_dir);
    execCmd('rm', '-r', $tmp_dir);
}

=back

=head1 AUTHOR

Hannes Hoerl E<lt>hannes.hoerl@snowreporter.comE<gt>

